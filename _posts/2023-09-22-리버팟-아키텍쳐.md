---
layout: post
title:  "리버팟 아키텍쳐"
date:   2023-09-22 13:41:00 +0530
tags: [dev]
---

처음 무작정 코딩할 때와 달리 앱의 규모가 커지면서 구조적인 복잡성에 대한 고민이 커졌다. 이런저런 자료들을 공부한 결과 나만의 아키텍쳐를 만들게 되었고, 이를 정리해 보고자 한다(사실 아키텍쳐라는 표현을 붙일 만큼 대단한 결과물은 아니지만 딱히 다른 용어가 생각나지 않아 아키텍쳐라는 표현을 사용하기로 한다).

물론 지금 정한 아키텍쳐가 영원불변하지는 않는다. 경험이 쌓일수록 생각이 성장하고 새로운 인사이트를 얻게 된다. 그러면 아키텍쳐도 발전하기 마련이다. 단지 현재 내가 가진 시야에서 최선의 아키텍쳐를 고안했을 뿐이다.


```dart
lib
│
├── api
│
├── auth
│    ├── component 
│    ├── controller 
│    ├── dto
│    ├── model
│    ├── repository
│    ├── state
│    └── view
│
│
├── common
│    ├── component
│    ├── layout
│    ├── model
│    ├── provider *
│    ├── util
│    └── value
│
│
├── feature
│    └── article
│           ├── component
│           ├── controller
│           ├── dto
│           ├── model
│           ├── repository
│           ├── state
│           └── view
│
└── message


- 모든 폴더명은 "단수"와 "소문자"만을 사용한다.
```



# Overall

- 기존 버전과 달라진 점은 화면 중심의 설계에서 기능 중심의 설계로 바뀌었다는 점이다. 이것을 도메인 주도 개발이라고 하지만 나는 그 용어의 의미를 아직 정확하게 이해하지 못하기 때문에 함부로 사용하지는 않겠다.  화면 중심의 설계에서 기능 중심의 설계로 바꾼 이유는 다음과 같다.
	1. 화면을 기준으로 구조를 설계하면 각 화면별로 Controller 를 하나 이상 두는 것이 부자연스러웠다. 하지만 기능 중심의 설계에서는 이런 부자연스러움이 없다. 다양한 역할을 하는 Controller 들을 필요한 만큼 마음껏 만들어서 화면에 데이터를 제공해 주면 된다.
	2. 코딩 편의성도 높아졌다. 화면 중심의 설계에서는 repository, model 을 서로 다른 폴더에 묶어 두었다. 하지만 기능 중심의 설계에서는 각 기능별로 model, repository, view 를 묶어 둠으로써 필요한 파일들을 일목요연하게 정리할 수 있다.

- 기존 버전과 달라진 점 두 번째는 바로 Dto 를 사용했다는 것이다. Model 을 직접 앱에서 사용하기 보다는 Dto 형태로 재정의해서 사용한다. 이렇게 하면 API 스펙이 바뀌거나 혹은 API 스펙이 앱의 상황과 맞지 않을 때 유연하게 대처 할 수 있다.



# Layers



#### model and dto

- Model 은 Entity 와 같은 개념이다. Database 스펙과 직접 맞닿아 있고, 웬만하면 변경해서는 안되는 Class 이다.  그래서 Model 을 앱에서 직접 사용하지 않고 Dto 형태로 재가공해서 사용한다.
- 나는 여기서 한 단계 더 나아간다. 나는 이것을 Data 패턴이라고 부를 것이다. 구체적인 내용은 다음과 같다.
	- Dto 를 정의 할 때 하나의 데이터를 담을 Data 와 리스트 형태로 데이터를 담을 DataList 를 만든다. 그리고 이들 각자는 sealed class 로 데이터가 존재하는 경우를 뜻하는 DataPresent와 부존재하는 경우를 뜻하는 DataEmpty 를 만든다.
	- 특히 Data List 에는 sort, add, replace, delete 같은 간단한 비지니스로직도 포함했다. 그래서 NotifierProvider 내부에서 간편하게 데이터를 추가하거나 삭제 할 수 있다. 만약 이렇게 하지 않으면 NotifierProvider 내부에서 복잡하고 반복적인 코드를 끊임없이 작성해야만 한다.
	- Data 패턴을 정의하는 것은 live template 으로 만들어 놨으니 적극 사용하자! (단축키 sealedData)
- dto 네이밍에 대한 고민
	- (김영한) 안녕하세요. 꼭 DTO를 적을 필요는 없습니다! MemberRequest MemberParameter MemberParam 등등을 사용하셔도 됩니다. 저의 경우 검색 조건이 되는 DTO는 MemberCondition 또는 MemberCond 단순 파라미터들은 MemberParam 등으로 분류해서 사용하기도 합니다. 감사합니다.



#### provider

- provider 는 stateless provider 로서, app 의 infrastructure 를 제공하는 역할을 한다.
- 예를 들어 http 인스턴스, secure_storage 인스턴스, tokenManager 인스턴스 등 app 에서 가장 기본적으로 사용해야 하는 인스턴스를 싱글톤으로 제공하는 역할을 맡는다.



#### repository using dto

- repository 는 stateless provider 로 만들었다. repository 의 역할은 단순하다. DataSource 로 부터 ApiResponse 를 받아와서 Model 로 변환하고, Controller 가 요구하는 형태의 Dto 로 다시 변환해서 반환하는 역할을 한다. 앞서 밝힌 Dot 의 세 가지 유형 single, list, empty 마다 적절한 형태의 응답을 생산해 낼 책임도 있다.
- 이때 DataSource 로 부터 받은 HttpStatusCode 를 app 내에서 미리 약속한 형태의 message 로 변환하는 역할도 수행한다. 



#### state

- state 은 화면이나 토큰 등의 상태를 표현하기 위해 만든 sealed class 이다. 주로 View 상태를 StateIdle, StateLoading, StateReady, StateError 로 나누어서 표현한다. 특히 State Ready 에는 View 에서 사용할 Dto 를 변수로 정의해 두었다. 그리고 State Error 에는 repository 가 해석한 Error Message 를 저장해서 View 에서 사용 할 수 있도록 했다.
- View 뿐만 아니라 Auth 의 상태도 AuthLoggedIn, AuthLoggedOut 으로 표현해 보았다. 무엇이 되었든 Controller 를 통해 View 에서 사용할 상태들을 state로 정의해서 사용하면 된다.
- state 를 정의하는 것 또한 live template 으로 만들어 놨으니 적극 사용할 것! (단축키 sealedState)



#### controller

- controller 는 데이터 플로우의 최전방에 있다. 반드시 stateful provider (주로 NotifierProvider)로 만들어서, state 의 값을 조율하고, 변동시키는 역할을 한다. 
- 그리고 사용자가 View 를 통해 이벤트를 발생시키면 controller 의 로직들이 실행된다.
- controller 는 앱 전반에 걸쳐 계층의 구분 없이 사용할 수 있다. 이렇게 정한 이유는 다음과 같다.
	1. controller 는 데이터 플로우의 최종 단계이기 때문에 서로 상호참조해도 repository 에서 controller 로 이어지는 구조가 엉킬 염려가 없다.
	2. 화면 구성에 관한 요구사항은 너무 다양하다. 어느 view에서 어떤 controller를 사용할지 혹은 역으로 어느 controller 에서 어떤 view를 컨트롤 할지는 일률적으로 정할 수 없다. 따라서 이런 요구사항을 충족시키기 위해서는 controller 만은(레파지토리는 아님!) 자유롭고 유연하게 사용 할 수 있어야 한다. 예를 들어 댓글을 작성하는 과정 중에 댓글 작성화면 너머의 게시물 목록 화면이 즉각적으로 업데이트 되도록 구현한다면 댓글 controller 에서 게시물 controller 를 사용 할 수 있어야 한다. controller 상호간의 참조를 금지하면 이런 기능을 구현하는데 필요이상의 노력이 필요하다. 그에 반해 controller 상호참조로 인한 설계상의 불리함은 전혀 없다.
	3. 이때 controller의 역할이 비대해질 위험이 있는데, 이것은 최대한 화면을 View 단위로 잘개 쪼개고, 그 View 마다 controller를 세세하게 설정하는 방식으로 해결가능하다. 이렇게 하면 화면의 작은 부분 까지 정밀하게 상태관리 할 수 있다. 그리고 각 controller 에서 다른 화면을 가리키는 controller 까지 조절하면 다양한 화면을 responsive 하게 구성 할 수 있다.
- 이때 한가지 규칙을 정한다! View 에서만 controller 를 watch 하고, Component 는 View 에 종속되어 View 로부터 data 를 전달받아야 한다.



#### view

- view 는 말 그대로 ui 를 표현하고 이용자로 부터 발생하는 이벤트를 수신해서 controller 를 작동시키는 역할을 한다.
- 항상 controller provider 를 watch 하고 있어야 한다.
- 그리고 재사용성 있는 부분은 최대한 잘게 component화 해서 코드를 간략하고 읽기 쉽게 관리해야 한다.
